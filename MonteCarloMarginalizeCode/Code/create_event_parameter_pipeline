#! /usr/bin/env python
#
# GOAL
#     Pipeline generation (including datafind, etc) to analyze real events, 
#     in 'model analysis' mode, using multiple iterations of fitting and ILE code.
#
# REFERENCES
#    lalinfereence_pipe
#    
#      https://lscsoft.docs.ligo.org/lalsuite/lalinference/lalinference__pipe_8py_source.html
#      https://github.com/lscsoft/lalsuite/blob/master/lalinference/python/lalinference/lalinference_pipe_utils.py
#      https://github.com/lscsoft/lalsuite/blob/master/lalinference/src/lalinference_pipe_example.ini
#      https://github.com/lscsoft/lalsuite/blob/master/lalinference/python/lalinference_pipe.py




from lalinference import lalinference_pipe_utils as pipe_utils
from lalapps import inspiralutils
from six.moves import configparser
from optparse import OptionParser,OptionValueError
import sys
import ast
import os
import uuid
from glue import pipeline
from math import ceil

usage=""" %prog [options] config.ini
 Setup a Condor DAG file to run the LALInference pipeline based on
 the config.ini file.
 
 The user can specify either an XML or a 
 a GraceDB ID with the --gid option
 or an ASCII list of GPS times with the --gps-time-file option.
 
 The user must also specify and ini file which will contain the main analysis config.
"""

parser=OptionParser(usage)
parser.add_option("-r","--run-path",default=None,action="store",type="string",help="Directory to run pipeline in (default: $PWD)",metavar="RUNDIR")
parser.add_option("-p","--daglog-path",default=None,action="store",type="string",help="Path to directory to contain DAG log file. SHOULD BE LOCAL TO SUBMIT NODE",metavar="LOGDIR")
parser.add_option("--gps",action="append",type="string",default=None,help="Analyse GPS time",metavar="GPSTIME")
parser.add_option("-g","--gps-time-file",action="store",type="string",default=None,help="Text file containing list of GPS times to analyse",metavar="TIMES.txt")
parser.add_option("-t","--single-triggers",action="store",type="string",default=None,help="SnglInspiralTable trigger list",metavar="SNGL_FILE.xml")
parser.add_option("-C","--coinc-triggers",action="store",type="string",default=None,help="CoinInspiralTable trigger list",metavar="COINC_FILE.xml")
parser.add_option("--gid",action="store",type="string",default=None,help="GraceDB ID")
parser.add_option("--condor-submit",action="store_true",default=False,help="Automatically submit the condor dag") 


# We will store variations of runs to use here as a dictionary of
# ((section, option), ...) : [variation1, ...]
# Where (section, option) indicate the configparser option to vary
# and multiple section,option pairs are allowed
variations={}
 
## 
# Helper function. Make the given directory, creating intermediate
# dirs if necessary, and don't complain about it already existing.
#   
def mkdirs(path):
   if os.access(path,os.W_OK) and os.path.isdir(path): return
   else: os.makedirs(path)
 
 ## 
 # Push some possible variations onto the stack.
 # If only one value is specified then just store it in cp as usual
 # cp : ConfigParser object to look in
 # section : [section] in cp
 # option : option in section
 # values: If given, use instead of cp's
 # allowed_values : if given, anything else will trigger an error
 #     
def add_variations(cp, section, option, values=None, allowed_values=None):
     if not cp.has_section(section) and not cp.has_option(section,option):
         return
 
     if values is not None:
         vals = values
     else:
         vals = cp.get(section,option).split(',')
     if allowed_values is not None and any(not vals in allowed_values):
         raise ValueError("Unknown value for {section} . {option} {value}"
                          .format(section, option, \
                              ' '.join([v for v in vals if v not in allowed_options])
                                 )
                          )
     if len(vals) >1:
         return {(section,option): vals}
     elif len(vals)==1:
         cp.set(section, option, vals[0])
         return {}
     else:
         print("Found no variations of [{section}] {option}".format(section=section,
                                                                    option=option))
         return {}
 
## 
# Generate config parser objects for each of the variations
#     
def generate_variations(master_cp, variations):
     cur_basedir=master_cp.get('paths','basedir')
     mkdirs(cur_basedir)
     # save the master file
     masterpath=os.path.join(cur_basedir,'config.ini')
     with open(masterpath,'w') as cpfile:
         master_cp.write(cpfile)
 
     cur_webdir=master_cp.get('paths','webdir')
     cur_dagdir=master_cp.get('paths','daglogdir')
     # If no variations, done
     if not variations:
         yield master_cp
         raise StopIteration()
 
     # Otherwise, vary over the next option
     (section, opt), vals = variations.popitem()
     for val in vals:
         # Read file back in to get a new object
         cp = configparser.ConfigParser()
         cp.optionxform = str
         cp.read(masterpath)
         cp.set(section,opt,val)
         # Append to the paths
         cp.set('paths','basedir',os.path.join(cur_basedir, \
                                         '{val}'.format(opt=opt,val=val)))
         cp.set('paths','webdir',os.path.join(cur_webdir, \
                                         '{val}'.format(opt=opt,val=val)))
         cp.set('paths','daglogdir',os.path.join(cur_dagdir, \
                                         '{val}'.format(opt=opt,val=val)))
         # recurse into remaining options
         for sub_cp in generate_variations(cp,variations):
             yield sub_cp
 
if len(args)!=1:
   parser.print_help()
   print 'Error: must specify one ini file'
   sys.exit(1)
 
inifile=args[0]
 
cp=configparser.SafeConfigParser()
fp=open(inifile)
cp.optionxform = str
cp.readfp(fp)
fp.close()
 
# Set the base directory for the run
if opts.run_path is not None:
     cp.set('paths','basedir',os.path.abspath(opts.run_path))
if cp.get('paths','basedir') is None:
     print("Warning: no run dir set, using current dir")
     cp.set('paths','basedir',os.path.getcwd())
mkdirs(cp.get('paths','basedir'))
 
if opts.daglog_path is not None:
     cp.set('paths','daglogdir',os.path.abspath(opts.daglog_path))
else:
     cp.set('paths','daglogdir',os.path.abspath(cp.get('paths','basedir')))
daglogdir=cp.get('paths','daglogdir')
mkdirs(daglogdir)
 
 
 # Set up from all the various input options
if opts.gps_time_file is not None:
     cp.set('input','gps-time-file',os.path.abspath(opts.gps_time_file))
if opts.single_triggers is not None:
     cp.set('input','sngl-inspiral-file',os.path.abspath(opts.single_triggers))
if opts.coinc_triggers is not None:
     cp.set('input','coinc-inspiral-file',os.path.abspath(opts.coinc_triggers))
if opts.gid is not None:
     cp.set('input','gid',opts.gid)
 
 # Some sanity checking
approx='approx'
if not (cp.has_option('engine','approx') or cp.has_option('engine','approximant') ):
     print "Error: was expecting an 'approx' filed in the [engine] section\n"
     sys.exit(1)


 # Build a list of allowed variations
variations.update(add_variations(cp, 'engine','approx'))


 # Create an outer dag to wrap the sub-dags
outerdaglog=os.path.join(daglogdir,'lalinference_multi_'+str(uuid.uuid1())+'.log')
outerdag=pipeline.CondorDAG(outerdaglog,dax=False)
outerdag.set_dag_file(os.path.join(cp.get('paths','basedir'),'multidag'))
