#! /usr/bin/env python
#
#  Based on generate_initial_grid_based_of_gstlal_O2_overlaps.py from Caitlin Rose (?)
#
# 20190215
#
# The overlap files for the gstlal O2 template bank described in https://arxiv.org/abs/1812.05121
# were generated by Heather Fong. 
# The overlap banks are split by Mchirp, with about 500 templates per subbank.
#
# This script sets up the command line to run lalsuite rapidpe_compute_intrinsic_grid to generate
# the initial grid for this rapidpe run. 
#
# For now the lalsuite code is only setup for grids in mass1 mass2 space. it needs to be expanded
#
# This script can be run in two ways
# generate_initial_grid_based_of_gstlal_O2_overlaps.py path_to_config_file
# or
# generate_initial_grid_based_of_gstlal_O2_overlaps.py path_to_config_file "{output_event_ID=name,intrinsic_param=[mass1=1.4,mass2=1.4]}"
# or with spin:
# generate_initial_grid_based_of_gstlal_O2_overlaps.py path_to_config_file "{output_event_ID=name,intrinsic_param=[mass1=1.4,mass2=1.4,spin1z=0.01,spin2z=0.01]}"
# 
# The output file is placed in the event directory
#


import argparse
import sys,os,json,ast,glob,h5py

import numpy as np
from sklearn.neighbors import BallTree
from modules import *
import configparser
from configparser import ConfigParser
cfg = ConfigParser()
cfg.optionxform = str

sys.exit(0)  # Currently fail, because we haven't written it to have properly flexible arguments, etc following convention of other routines.


cfgname = sys.argv[1]
cfg.read(cfgname)

print(("CFGNME",cfgname))
output_parent_directory= cfg.get("General","output_parent_directory") # output parent dir for all triggers from same scenario study etc.

if len(sys.argv) == 2:
    kwargs = convert_section_args_to_dict(cfg,"Event")

elif len(sys.argv) == 3:
    kwargs = convert_dict_string_to_dict(sys.argv[2])
#ast.literal_eval(sys.argv[2])
else:
    sys.exit("ERROR: too many input arguments")

output_event_directory= kwargs["output_event_ID"] #the output directory for the single event trigger being followed up here
intrinsic_param = convert_list_string_to_dict(kwargs["intrinsic_param"])
distance_coordinates = cfg.get("GridRefine","distance-coordinates") if cfg.has_option("GridRefine","distance-coordinates") else ""
additional_command_line_args = convert_cfg_section_to_cmd_line(cfg,"InitialGridOnly") if cfg.has_section("InitialGridOnly") else ""

script_directory = os.path.dirname(os.path.realpath(__file__))
output_dir = script_directory+"/"+output_parent_directory+"/"+output_event_directory+"/"

def main():

    print("kwargs",kwargs)
    print("the following will be added to the grid generation command line",additional_command_line_args)
    print("The directory for the output file is",output_dir)
    if not os.path.isdir(output_dir):
        os.system("mkdir -p "+output_dir)

    #make the output directory your working directory                                                                                                      
    os.chdir(output_dir)

#    exe = "python /home/sinead.walsh/Software/lalsuite_for_psiphimarg_v5_venv/src/lalsuite/lalinference/python/rapidpe_compute_intrinsic_grid.py" 
#    exe = "/home/sinead.walsh/Software/20190225_python27_lalsuite_for_automated_rapidpe_venv/opt/lalsuite/bin/rapidpe_compute_intrinsic_grid"
#    exe = "/home/sinead.walsh/Software/20190702_python27_lalsuite_for_automated_rapidpe_venv_v2/opt/lalsuite/bin/rapidpe_compute_intrinsic_grid" 
#    exe = "/home/caitlin.rose/virtualenvs/lalbranch_virtualenv/opt/bin/rapidpe_compute_intrinsic_grid"
    exe = "/home/vinaya.valsan/virtualenvs/rapidpe_new_19052021/opt/bin/rapidpe_compute_intrinsic_grid"
#    exe = "python /home/sinead.walsh/Software/20190225_python27_lalsuite_for_automated_rapidpe_venv/src/lalsuite/lalinference/python/rapidpe_compute_intrinsic_grid.py" 
    path_to_olap_files = "/home/sinead.walsh/20180214_O2_overlaps_from_heather_fong/"
    if not os.path.isdir(path_to_olap_files):
        sys.exit("ERROR: path to overlap files doesn't exist.You should be on CIT pcdev1")
    intrinsic_grid_name_base = "intrinsic_grid"
    initial_grid_xml = intrinsic_grid_name_base+"_iteration_0.xml.gz"
    initial_grid_hdf = intrinsic_grid_name_base+"_all_iterations.hdf"
    #now fill in the rest
    cmd = exe + " --verbose --no-exact-match --setup "+initial_grid_hdf+" --output-xml-file-name "+initial_grid_xml
    if distance_coordinates is not "":
        cmd += " -d "+distance_coordinates

    #Add the event trigger parameters, the inital grid will include all points in the overlap bank with overlap < the -T value  
    for param,val in intrinsic_param.items():
        print(param,val)
        cmd += " -i "+param+"="+str(val)

    cmd += additional_command_line_args


    #The overlap files are split by Mchirp, it takes time to check all files and see which one contains our signal. Here, we check the 
    m1 =float(intrinsic_param["mass1"])
    m2= float(intrinsic_param["mass2"])
    s1 = s2 = 0
    if "spin1z" in intrinsic_param:
        s1 =float(intrinsic_param["spin1z"])
        s2= float(intrinsic_param["spin2z"])
    
    chi_eff_event = transform_s1zs2z_chi(m1,m2,s1,s2)    
    Mchirp_event = ( (m1*m2)**(3/5.0) ) / ( (m1 + m2)**(1/5.0) )
    eta_event = ((m1*m2)/((m1+m2)**2.))
    print("Event mchirp",Mchirp_event,eta_event)

    #Reducing list of files to those in mchirp range
    olap_filenames = glob.glob(path_to_olap_files+"*.hdf")
    count_files = 0
    strings_to_include = "{"
    min_dist = -1
    min_dist_filename = ""
    for hdf_filename in olap_filenames:
        h5file = h5py.File(hdf_filename,"r")
        wfrm_fam = list(h5file.keys())[0]
        mdata = h5file[wfrm_fam]
#        m1, m2 = mdata["mass1"][:], mdata["mass2"][:]
        ntemplates = len(mdata["overlaps"])
        m1, m2 = mdata["mass1"][:ntemplates], mdata["mass2"][:ntemplates]
        Mchirps = ( (m1*m2)**(3/5.0) ) / ( (m1 + m2)**(1/5.0) )
#        print Mchirp_event,min(Mchirps),max(Mchirps)
        if Mchirp_event > min(Mchirps) and Mchirp_event < max(Mchirps):
            print(hdf_filename)
            s1, s2 = mdata["spin1z"][:ntemplates], mdata["spin2z"][:ntemplates]
            etas = ((m1*m2)/((m1+m2)**2.))
            chi_effs = transform_s1zs2z_chi(m1,m2,s1,s2)    
            #FIXME:even if youre not searching over spin, you want to find the file with the closest template assuming spin=0
            #implement above here at same time as code
            list_for_tree = np.asarray([Mchirps,etas]).T
            pt = np.asarray([Mchirp_event,eta_event])
            if "spin1z" in intrinsic_param:
                list_for_tree = np.asarray([Mchirps,etas,chi_effs]).T
                pt = np.asarray([Mchirp_event,eta_event,chi_eff_event])            

            tree = BallTree(list_for_tree)
            dist, m_idx = tree.query(np.atleast_2d(pt), k=1)
            if dist < min_dist or min_dist_filename == "":
                min_dist = dist
                min_dist_filename = hdf_filename

            count_files += 1
            if not "spin1z" in intrinsic_param:
                #FIXME: rapidpe compute grid doesn't consider spin when checking for the closest template, which can lead to incorrect overlaps with other templates because the spin of the closest template assuming zero spin is actually non-zero, and if that was taken into account it wouldn't be the closest template
                cmd += " --use-overlap "+hdf_filename

    if "spin1z" in intrinsic_param:                
        cmd += " --use-overlap "+min_dist_filename

    print(("CLA",cmd))
    print(("Command line includes",count_files,"files to read"))
    exit_status = os.system(cmd)
    if exit_status != 0:
        print(("ERROR with",cmd))
        sys.exit("ERROR: non zero exit status"+str(exit_status))

    print("[initial_grid_xml="+initial_grid_xml+",initial_grid_hdf="+initial_grid_hdf+"]")

    return

if __name__ == '__main__':
    main()
