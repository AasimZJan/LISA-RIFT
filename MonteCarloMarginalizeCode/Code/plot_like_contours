#!/usr/bin/env python
import sys
import types
from optparse import OptionParser

import matplotlib
matplotlib.use("Agg")
from matplotlib import pyplot

import numpy

from glue.ligolw import utils, table, lsctables

optp = OptionParser()
optp.add_option("--dimension1", help="Plot this column along the x-axis")
optp.add_option("--dimension2", help="Plot this column along the y-axis")
optp.add_option("--show-points", action="store_true", help="Scatter plot the points used.")
optp.add_option("--show-mdc", help="Mark MDC values from provided XML on the plots.")
opts, args = optp.parse_args()

if opts.dimension1 in ["mass1", "mass2"] and opts.dimension2 in ["mass1", "mass2"]:
    points = table.get_table(utils.load_filename(args[0]), lsctables.SnglInspiralTable.tableName)
    like = [row.snr for row in points]
    # FIXME: order
    points = [(row.mass1, row.mass2) for row in points]
    d1, d2 = numpy.array(points).T
elif opts.dimension2 is None:
    points = table.get_table(utils.load_filename(args[0]), lsctables.SimInspiralTable.tableName)

    if opts.show_mdc:
        sim = table.get_table(utils.load_filename(opts.show_mdc), lsctables.SimInspiralTable.tableName)
        assert len(sim) == 1
        sim = getattr(sim[0], opts.dimension1)
        pyplot.axvline(sim)

    # FIXME: We really need to get over this whole seconds/nanoseconds thing
    for point in points:
        point.geocent_end_time = point.geocent_end_time + 1e-9*point.geocent_end_time_ns
        # FIXME: HACKHACK
        if opts.show_mdc and opts.dimension1 == "geocent_end_time":
            point.geocent_end_time += sim

    # FIXME: Hardcoded bad column name
    points = [(getattr(row, opts.dimension1), row.alpha1) for row in points]
    points = numpy.array(sorted(points)).T
    
    pyplot.plot(points[0], points[1], 'k-')
    pyplot.grid()
    pyplot.xlabel(opts.dimension1)

    pyplot.savefig("%s_likelihood.png" % opts.dimension1)
    exit()

else:
    points = table.get_table(utils.load_filename(args[0]), lsctables.SimInspiralTable.tableName)
    # FIXME: We really need to get over this whole seconds/nanoseconds thing
    for point in points:
        point.geocent_end_time = point.geocent_end_time + 1e-9*point.geocent_end_time_ns
    # FIXME: Hardcoded bad column name
    like = [row.alpha1 for row in points]
    points = [(getattr(row, opts.dimension1), getattr(row, opts.dimension2)) for row in points]
    d1, d2 = numpy.array(points).T

d1min, d1max = min(d1), max(d1)
d2min, d2max = min(d2), max(d2)
d1step, d2step = (d1max-d1min)/100.0, (d2max-d2min)/100.0

#d1g, d2g = numpy.meshgrid(numpy.arange(1.0,2.0,0.1), numpy.arange(1.0,2.0,0.1))
d1g, d2g = numpy.meshgrid(numpy.arange(d1min, d1max, d1step), numpy.arange(d2min, d2max, d2step))
d1d2 = numpy.array(zip(d1g.flatten(), d2g.flatten()))

#from scipy.interpolate import griddata
#int_like = griddata((d1,d2), like, d1d2)
from matplotlib.mlab import griddata
int_like = griddata(d1, d2, like, d1g, d2g)

pyplot.contourf(d1g, d2g, int_like, 20)
pyplot.colorbar()
pyplot.grid()
if opts.show_points:
    pyplot.scatter(d1, d2, s=5.0, c=like)
pyplot.xlabel(opts.dimension1)
pyplot.ylabel(opts.dimension2)
pyplot.savefig("%s_%s_likelihood.png" % (opts.dimension1, opts.dimension2))
