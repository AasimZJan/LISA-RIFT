#!/usr/bin/env python
import sys
import types
from optparse import OptionParser

import matplotlib
matplotlib.use("Agg")
from matplotlib import pyplot
import matplotlib.cm
from matplotlib.mlab import griddata

from scipy import interpolate

import numpy

from glue.ligolw import utils, table, lsctables

optp = OptionParser()
optp.add_option("--dimension1", help="Plot this column along the x-axis")
optp.add_option("--dimension2", help="Plot this column along the y-axis")
optp.add_option("--full-likelihood", action="store_true", help="Take exponential of loglikelihood")
optp.add_option("--show-points", action="store_true", help="Scatter plot the points used.")
optp.add_option("--show-mdc", help="Mark MDC values from provided XML on the plots.")
optp.add_option("--fig-extension",help="Type of figure (png,pdf,jpg)",default="png")
opts, args = optp.parse_args()

if opts.dimension1 in ["mass1", "mass2"] and opts.dimension2 in ["mass1", "mass2"]:
    points = table.get_table(utils.load_filename(args[0]), lsctables.SnglInspiralTable.tableName)
    like = [row.snr for row in points]
    # FIXME: order
    points = [(row.mass1, row.mass2) for row in points]
    d1, d2 = numpy.array(points).T
elif opts.dimension2 is None:
    points = table.get_table(utils.load_filename(args[0]), lsctables.SimInspiralTable.tableName)

    fig = pyplot.figure()
    bottom = pyplot.subplot2grid((3,1), (2,0))
    top = pyplot.subplot2grid((3,1), (0,0), rowspan=2)

    if opts.show_mdc:
        sim = table.get_table(utils.load_filename(opts.show_mdc), lsctables.SimInspiralTable.tableName)
        assert len(sim) == 1
        if opts.dimension1 == "geocent_end_time":
            sim = float(sim[0].get_end())
        else:
            sim = getattr(sim[0], opts.dimension1)

        top.axvline(sim)
        bottom.axvline(sim)

    # FIXME: We really need to get over this whole seconds/nanoseconds thing
    for point in points:
        point.geocent_end_time = point.geocent_end_time + 1e-9*point.geocent_end_time_ns
        # FIXME: HACKHACK
        if opts.show_mdc and opts.dimension1 == "geocent_end_time":
            point.geocent_end_time += sim

    # FIXME: Hardcoded bad column name
    points = [(getattr(row, opts.dimension1), row.alpha1) for row in points]
    points = numpy.array(sorted(points)).T

    top.plot(points[0], points[1], "k-")

    # FIXME: For better plotting resolution, bin by dL/dx rather than linearly
    phist, bins = numpy.histogram(points[0], bins=100)
    like_intp = interpolate.interp1d(points[0], points[1])
    like_bins = like_intp(bins)

    # FIXME: Center bins
    bin_norm = matplotlib.colors.Normalize(min(phist), max(phist))
    sm = matplotlib.cm.ScalarMappable(norm=bin_norm)
    begin = numpy.vstack((bins[:-1], bins[1:])).T
    end = numpy.vstack((like_bins[:-1], like_bins[1:])).T
    segments = numpy.array(zip(begin, end))
    for i, seg in enumerate(segments):
        if i >= len(phist): break
        top.plot(seg[0], seg[1], color=matplotlib.cm.hsv(sm.norm(phist[i])) )
    sm.set_array(like_bins)
    sm.cmap = matplotlib.cm.hsv
    pyplot.gcf().colorbar(sm)

    # NOTE: Reenable for inset histogram
    #ax_inset = fig.add_axes([0.4, 0.2, 0.3, 0.3])
    #ax_inset.hist(points[0], bins=100)
    bottom.hist(points[0], bins=100)

    bottom.set_xlabel(opts.dimension1)
    top.grid()
    bottom.grid()

    pyplot.savefig(opts.dimension1+"_likelihood." +opts.fig_extension )
    exit()

else:
    # FIXME: HACKHACK
    if opts.show_mdc:
        sim = table.get_table(utils.load_filename(opts.show_mdc), lsctables.SimInspiralTable.tableName)
        assert len(sim) == 1
        if opts.dimension1 == "geocent_end_time":
            sim = float(sim[0].get_end())
        else:
            sim = getattr(sim[0], opts.dimension1)

    points = table.get_table(utils.load_filename(args[0]), lsctables.SimInspiralTable.tableName)
    # FIXME: We really need to get over this whole seconds/nanoseconds thing
    for point in points:
        point.geocent_end_time = point.geocent_end_time + 1e-9*point.geocent_end_time_ns
        if opts.show_mdc:
            point.geocent_end_time += sim
    # FIXME: Hardcoded bad column name
    like = [row.alpha1 for row in points]
    points = [(getattr(row, opts.dimension1), getattr(row, opts.dimension2)) for row in points]
    d1, d2 = numpy.array(points).T

#
# Determine grid limits
#
d1min, d1max = min(d1), max(d1)
d2min, d2max = min(d2), max(d2)
d1step, d2step = (d1max-d1min)/100.0, (d2max-d2min)/100.0

#
# Create grid to interpolate to
#
d1g, d2g = numpy.meshgrid(numpy.arange(d1min, d1max, d1step), numpy.arange(d2min, d2max, d2step))
d1d2 = numpy.array(zip(d1g.flatten(), d2g.flatten()))

# FIXME: Reenable when available
#from scipy.interpolate import griddata
#int_like = griddata((d1,d2), like, d1d2)
int_like = griddata(d1, d2, like, d1g, d2g)

if opts.full_likelihood:
    pyplot.contourf(d1g, d2g, numpy.exp(int_like), 20)
else:
    pyplot.contourf(d1g, d2g, int_like, 20)

if opts.show_mdc:

    sim = table.get_table(utils.load_filename(opts.show_mdc), lsctables.SimInspiralTable.tableName)
    assert len(sim) == 1
    if opts.dimension1 == "geocent_end_time":
        d1_sim = float(sim[0].get_end())
    else:
        d1_sim = getattr(sim[0], opts.dimension1)
    if opts.dimension2 == "geocent_end_time":
        d2_sim = float(sim[0].get_end())
    else:
        d2_sim = getattr(sim[0], opts.dimension2)
    pyplot.axvline(d1_sim, color='k', linewidth=2, alpha=0.5)
    pyplot.axhline(d2_sim, color='k', linewidth=2, alpha=0.5)

pyplot.colorbar()
pyplot.grid()
if opts.show_points:
    pyplot.scatter(d1, d2, s=5.0, c=like)
pyplot.xlabel(opts.dimension1)
pyplot.ylabel(opts.dimension2)
pyplot.savefig(opts.dimension1+"_"+opts.dimension2+"_likelihood." +opts.fig_extension )
#pyplot.savefig("%s_%s_likelihood.png" % (opts.dimension1, opts.dimension2))
